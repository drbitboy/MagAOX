#!/usr/bin/env bash

########################################################################
### Main routine:  parse commands; print Usage; call the verb's function
function resuctl_main {

  misc_setup

  parse_commands $* || return 1

  [ "$Helped" ] && return 0

  verb_${verb}
}

########################################################################
### Startup:  if resurrector_indi is not running, and configuration file
###           is readable, then start resurrectee_indi with stated $ROLE
function verb_startup {

  hide

  ripid=$(resurrector_indi_pid) \
  && ( [ "$verb" == "restart" ] \
     || echo "${RED_SEQ}resurrector_indi already running PID{$ripid}; exiting ...${RESET_SEQ}" 1>&2 \
     || true
     ) \
  && return 1

  proclist_txt="$(proclist_path) readonly" \
  || ( echo "${RED_SEQ}Readable process list file not found; exiting ...${RESET_SEQ}" 1>&2 && false) \
  || return 1

  command="./resurrector_indi -r $ROLE"
  echo "${GREEN_SEQ}$command &${RESET_SEQ}"
  $command &
}

########################################################################
### Shutdown:  if resurrector_indi is active, then signal it via SIGUSR1
###            to trigger killing its INDI driver devices before exiting
function verb_shutdown {

  hide

  ripid=$(resurrector_indi_pid) \
  || ( echo "${RED_SEQ}resurrector_indi is not running; exiting ...${RESET_SEQ}" 1>&2 && false ) \
  || return 1

  command="kill -USR1 $ripid"
  echo "${GREEN_SEQ}$command${RESET_SEQ}"
  $command
}

########################################################################
### Restart:  first shutdown, then startup, the resurrector_indi process
function verb_restart {
  hide
  verb_shutdown
  sleep 5
  verb_startup
}

########################################################################
### Start:  edit process list file to enable selected devices, then send
###         signal SIGUSR2 to resurrector_indi to re-start those devices
function verb_start {

  hide

  [ "$procnames" ] \
  || Usage "ERROR:  command [start] requires PROCNAME(s)" \
  || return 1

  proclist_txt="$(proclist_path)" \
  || ( echo "${RED_SEQ}Writable process list file not found; exiting ...${RESET_SEQ}" 1>&2 && false ) \
  || return 1

  for procname in $procnames ; do
    ### Remove any leading whitespace+# for proclist file procname entry
    sed -i -e "/^$ws*#$wsh*${procname}$ws$ws*$notws$notws*$ws*\$/s/^$wsh*//" "$proclist_txt"
  done

  ripid=$(resurrector_indi_pid) \
  || ( echo "${RED_SEQ}resurrector_indi is not running; exiting ...${RESET_SEQ}" 1>&2 && false ) \
  || return 1

  command="kill -USR2 $ripid"
  echo "${GREEN_SEQ}$command${RESET_SEQ}"
  $command
}

########################################################################
### Stop:  edit process list file to disable selected devices, then send
###        signal SIGUSR2 to resurrector_indi to terminate those devices
function verb_stop {

  hide

  [ "$procnames" ] \
  || Usage "ERROR:  command [stop] requires PROCNAME(s)" \
  || return 1

  proclist_txt="$(proclist_path)" \
  || ( echo "${RED_SEQ}Writable process list file not found; exiting ...${RESET_SEQ}" 1>&2 && false) \
  || return 1

  for procname in $procnames ; do
    ### Replace leading whitespace with # in proclist file procname line
    sed -i -e "/^$ws*${procname}$ws$ws*$notws$notws*$ws*\$/s/^$ws*/#/" "$proclist_txt"
  done

  ripid=$(resurrector_indi_pid) \
  || ( echo "${RED_SEQ}resurrector_indi is not running; exiting ...${RESET_SEQ}" 1>&2 && false ) \
  || return 1

  command="kill -USR2 $ripid"
  echo "${GREEN_SEQ}$command${RESET_SEQ}"
  $command
}

########################################################################
### Trigger resurrector to stop and start Heaxbeaters before they expire
function verb_defib {

  [ "$procnames" ] \
  || Usage "ERROR:  command [defib] requires PROCNAME(s)" \
  || return 1

  ripid=$(resurrector_indi_pid) \
  || ( echo "${RED_SEQ}resurrector_indi is not running; exiting ...${RESET_SEQ}" 1>&2 && false ) \
  || return 1

  for procname in $procnames ; do

    ### Find Hexbeater pipe path For each INDI driver device in the loop
    hbpath="$(find_live_hexbeat_pipe $procname)" \
    || ( echo "${RED_SEQ}resurrector_indi is not reading $procname's pipe; skipping this Hexbeater ...${RESET_SEQ}" 1>&2 && false ) \
    || continue   ### Skip devices to which resurrector is not listening

    ### Inject an expired Hexbeat into pipe; resurrector sees it as hung
    echo 000000000 >> "$hbpath"
    echo "${GREEN_SEQ}Defibrillated $procname${RESET_SEQ}"

  done || true
}

########################################################################
function verb_peek {
  hide
}

########################################################################
function verb_status {
  hide
}

########################################################################
### Parse command line; store the results in the various shell variables
function parse_commands {

  ### If -r was last command-line argument, ROLEisnext will be non-empty
  unset ROLEisnext
  unset Helped
  unset All

  ### Loop over command-line arguments
  for arg in $* ; do

    ### Ignore empty arguments
    ### -r or --role was previous argument; use current argument as ROLE
    [ "$arg" ] || continue
    [ "$ROLEisnext" ] && ROLE="$arg" && unset ROLEisnext && continue

    ### Parse arguments using case-esac statments
    case "$arg" in

    ### Verbs
    startup|shutdown|restart|start|stop|defib|peek|status)
      [ "$verb" ] && procnames="${procnames# }$(procname_pad)$arg"
      [ "$verb" ] || verb="$arg"
      ;;

    ### -r ROLE or --role ROLE
    -r|--role)
      [ "$ROLE" ] && ( Usage "Duplicate role; exiting..." || true ) && return 1
      ROLEisnext=$arg
      ;;

    ### -all
    --all)
      All=yes
      ;;

    ### Help
    -h|--help)
      Helped=yes
      Usage || return 0
      ;;

    ### Device name
    *)
      procnames="${procnames# }$(procname_pad)$arg"
      ;;
    esac
  done

  [ "$ROLEisnext" ] && ( Usage "ERROR:  missing role argument after [$ROLEisnext]" || true ) && return 1
  [ "$ROLE" ] || ROLE="$(printenv MAGAOX_ROLE)"
  [ "$ROLE" ] || Usage "ERROR:  missing role (${opt_magaox}/config/proclist_{MAGAOX_ROLE}.txt))" || return 1

  [ "$verb" ] || Usage "ERROR:  missing verb (status, peek, etc.)" || return 1

  [ "$All" ] && [ "$verb" != "startup" ] && [ "$verb" != "shutdown" ] \
  && ( Usage "Error:  --all option only valid for commands startup and shutdown" || true ) && return 1

  [ "$All" ] && [ "$procnames" ] \
  && ( Usage "Error:  --all option mutually exclusive with PROCNAME options [$procnames]" || true ) && return 1

  true
} ### function parse_commands

########################################################################
### Logic to optionally insert padding between INDI driver process names
function procname_pad { [ "$procnames" ] && echo -n ' '; }

########################################################################
### Find PID of running resurrector_indi
function proclist_path {
  the_proclist="${opt_magaox}/config/proclist_${ROLE}.txt"
  [ -r "$the_proclist" ] \
  && [ "$1" == "readonly" -o -w "$the_proclist" ] \
  && ls -d "$the_proclist"
}

########################################################################
### Find the PID of the first running resurrector_indi that can be found
function resurrector_indi_pid {

lsof +c 0 | grep --color=never 'txt.*/resurrector_indi$' \
| while read ri pid user txt reg device size_off node exe cruft ; do
    [ "$txt" == "txt" ] \
    && [ "$(basename "$exe")" == "resurrector_indi" ] \
    && [ "$pid" ] \
    && echo $pid | grep '^[1-9][0-9]*$' \
    && break
  done | grep --color=never .    ### Return failure if nothing was found
}

########################################################################
### Find a Hexbeater pipe that is being read by the resurrector_indi app
### N.B. this only returns success code zero if such a pipe is detected,
###      and in every other situation it returns a non-zero failure code
###
### Usage:
###
###   find_live_hexbeat_pipe xy  ### for /opt/MagAOX/drivers/fifos/xy.hb
###
###   hbpath=$(find_live_hexbeat_pipe xy) || echo "Pipe xy is not alive"
###
function find_live_hexbeat_pipe {

  ### The first column of the lsof output will be a subset of this name:
  ri="resurrector_indi"

  fdir="${opt_magaox}/drivers/fifos/"     ### Named FIFOs are under here

  hbpath="$(find "$fdir" -type p -name "${1}.hb" | head -1 | grep . )" \
  || return 1

  ### List all processes that have that file open; find resurrector_indi
  lsof +c 0  "$hbpath" \
  | while read cmd pid user fd type dev sizeoff mode path the_cruft ; do

      ### ripid=... => fails if resurrector_indi is not currently active
      ### ${ri#${cmd}} => fails if cmd is not subset of resurrector_indi
      ### $pid => fails if pid with pipe open is not of resurrector_indi
      ### ${fd%w} => fails if [pid] process has pipe open for write only
      ### echo "$path" - write path of pipe accessed by resurrector_indi
      ### break out of loop when pipe accessed by resurrector_indi found

      ripid=$(resurrector_indi_pid) \
      && [ "${ri#${cmd}}" != "$ri" ] \
      && [ "$pid" == "$ripid" ] \
      && [ "${fd%w}" == "$fd" ] \
      && echo "$path" \
      && break

    done | grep --color=never .  ### Return failure if nothing was found
}

########################################################################
function Usage {
cat << EoF
usage: [MAGAOX_ROLE=ROLE] resuctrl [-h|--help] [-r ROLE|--role ROLE] \\
             startup|shutdown|restart|start|stop|defib|peek|status \\
             [PROCNAME[ PROCNAME[ ...]]]

MagAO-X Process Control

Usage:

    resuctrl startup [--all]
        - startup resurrector_indi and all processes in proclist

    resuctrl shutdown [--all]
        - shutdown all processes including resurrector_indi

    resuctrl restart
        - have resurrector_indi shutdown then startup each running process

    resuctrl start PROCNAME[ PROCNAME[ ...]]
        - enable and start PROCNAME processes in proclist

    resuctrl stop PROCNAME[ PROCNAME[ ...]]
        - disable and stop PROCNAME processes in proclist

    resuctrl defib PROCNAME[ [PROCNAME ...]]
        - show status and last few log lines for each process

    resuctrl peek PROCNAME [PROCNAME ...]
        - show status and last few log lines for each process

    resuctrl status PROCNAME [PROCNAME ...]
        - show status and last few log lines for each process

positional arguments:
  {status,peek,shutdown,stop,restart,startup,start}
                        verb for action to take

proclist is contents of file::
  ${opt_magaox}/config/proclist_${MAGAOX_ROLE}.txt

optional arguments:
  -h, --help            show this help message and exit
  -r ROLE, --role ROLE  Specify role to read proclist for (default:$MAGAOX_ROLE)

$RED_SEQ$*$RESET_SEQ
EoF

return 1

####################################
### Obsolete:
###    resuctrl inspect PROCNAME
###        - connect to the tmux session for PROCNAME
####################################
}

########################################################################
function hide {
  ( [ "$VERBOSE" ] && cat || cat > /dev/null ) << EoFhide
verb{$verb}:
- ROLE{$ROLE}
- procnames{$procnames}
- All{$All}
EoFhide
}

########################################################################
### MagAOX root directory; sequences for color highlighting; grep regexp
function misc_setup {

  opt_magaox="/opt/MagAOX"

  RED_SEQ="$(tput setaf 1)"
  GREEN_SEQ="$(tput setaf 2)"
  YELLOW_SEQ="$(tput setaf 3)"
  BLUE_SEQ="$(tput setaf 4)"
  RESET_SEQ="$(tput sgr0)"

  ### whitespace:  ws=>tab+space; wsh=>#+tab+space; notws=>not-tab+space
  ws="[ 	]"
  wsh="[# 	]"
  notws="[^ 	]"

  true
}

########################################################################
### All functions have been read in; start by calling resuctl_main above
resuctl_main $*
